---
typora-copy-images-to: img\02
---

# 模块

## ★CommonJS 规范

关于 Node.js 的模块规范，也就是CommonJS规范

模块规范是做一个大型  Node.js 应用程序的基础，所以这是非常关键的！

在讲解它之前，先来回顾前端是如何加载 JS 的。

在浏览器里边我们都是用`script`标签去加载 JS 的

如果script标签里边有个src属性，那么浏览器就会从远端下载个 JS 脚本下来，并且执行它！

反之，咩有这个src属性，那么浏览器就会直接把script里边的代码给执行一遍哈！

而这就是我们以前唯一的一种加载 JS 的方法！

那么用script标签去加载 JS 会有一个什么样的问题呢？

**①当脚本变得很多的时候，我们需要手动去管理这个 JS 的加载顺序。**

举个栗子来说，当你的业务代码使用了jQuery这个JS，那么你就需要把jQuery放在第一个script标签上去加载！然后再去运行的你业务脚本，如果就引入一两个库，这样做其实是没啥问题的，但是如果变得越来越多之后呢？如你不只是引入jQuery，还引入Underscore 等其它奇奇怪怪的函数库 ，而这样一来你需要管理的脚本数量就变得非常多了，而这也意味着有很大管理成本

**②不同脚本之间，如果产生逻辑调用，那么这是需要一个全局变量作为桥梁去做通信的！**

就拿刚才那个jQuery例子来说，jQuery的所有函数都是挂在一个全局变量 `$`上的，我们每一次调用jQuery都是访问 `$`变量，然后去找它里边的函数，然后去调用。简而言之，就是说每一个脚本的逻辑输出，都得输出到一个全局变量上才能被其它脚本所调用！如果你的脚本变得非常多，那么你要用的全局变量也就越来越多了！而全局变量多了，那么你的程序就很难管理了！因为你很难确定哪一天自己的全局变量就会被人所覆盖，说白了，某个全局变量被覆盖了，那么你的 Node.js 程序也就GG了。

**③当一个 JS 的运行环境它咩有HTML，那该咋办呢？**

而这个例子就是 Node.js ，我们运行 Node.js 其实咩有经过任何的HTML文件的，而这就意味着我们是没有地方去写一个script标签了啊！

所以 Node.js 是需要重新去搞一个模块管理的机制，来管理我们 JS 的加载

而这个机制就是 CommonJS 模块规范啦！  

 CommonJS 其实并不是一个模块规范的名字，它是一个非常庞大的东西，只是现在只有模块规范是留着的，因为它被 Node.js 所采用，并且推广，由于它非常经典，后续也影响到了浏览器端 JS 的编写方式！







## ★总结

- 在 Node.js 里边，你执行的是一个入口 JS 文件，剩余的其它 JS 文件，请在入口 JS 文件里边用 `require`来搞事情！而这个入口 JS 文件，一般叫做 index.js ，或者 app.js
- 只用`module.exports`输出一个东西，而不是用 `exports`，因为如果你无法区分二者的话，那么使用后者是很危险的！如「如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在`module.exports`变量上面。」这个点，你知道吗？
- 规范即代码运行所遵循的规则！白话点就是，规定这样的输入会有这样的输出，而代码的具体实现过程可看做是个黑盒子。

## ★Q&A

### ① CommonJS ？

CommonJS是一个项目，目标是在Web浏览器之外为JavaScript建立模块生态系统的约定。创建它的主要原因是**缺乏普遍接受的**的JavaScript脚本模块单元，这些模块单元可以在不同于常规的Web浏览器提供的环境中重用，如运行 JS 脚本的web服务器或者是原生桌面端应用程序。

起初2009年一月份，它叫 ServerJS，在同年的八月份，它才正式叫做  CommonJS 

为啥叫 CommonJS 呢？——因为要展示它的APIs有广泛地适用性啊！（ Common，普遍的，常见的……）

规范是在一个被大众所认可的开放过程中才被创建的。一个规范的最终诞生，只有在通过多个实现完成之后才被认为是最终规范。

CommonJS不隶属于致力于EcmaScript的ECMA国际集团TC39，但TC39的一些成员参与了该项目

然而在2013年5月，Node.js的包管理器npm的作者Isaac Z. Schlueter说，CommonJS正在被Node.js淘汰，核心Node.js开发人员应该避免使用 CommonJS 规范。

虽然如此，但还是得了解它哈！

Node 应用由模块组成，采用 CommonJS 模块规范。

每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。如

```js
// example.js
var x = 5; //私有的
var addX = function (value) {
  return value + x;
};
```

如果想在多个文件分享变量，必须定义为`global`对象的属性

```js
global.warning = true; //不推荐
```

上面代码的`warning`变量，可以被所有文件读取。当然，这样写法是不推荐的。

CommonJS规范规定，每个模块内部，`module`变量代表当前模块。这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。加载某个模块，其实是加载该模块的`module.exports`属性。

`require`方法用于加载模块。

**CommonJS模块的特点如下：**

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。

**module对象：**

Node内部提供一个`Module`**构建函数**。所有模块都是`Module`的实例。

```js
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  // ...
}
```

总之，每个模块内部，都有一个`module`对象（你是看不见它的，执行模块时 nod e命令会知道），代表当前模块。它有以下属性。

- `module.id` 模块的识别符，通常是带有绝对路径的模块文件名。
- `module.filename` 模块的文件名，带有绝对路径。
- `module.loaded` 返回一个布尔值，表示模块是否已经完成加载。
- `module.parent` 返回一个对象，表示调用该模块的模块。
- `module.children` 返回一个数组，表示该模块要用到的其他模块。
- `module.exports` 表示模块对外输出的值。

最后一行输出module变量：

```js
// 01-test.js
var jquery = require('jquery');
exports.$ = jquery;
console.log(module);
console.log(exports);
```

> module变量就是模块里边的隐式的全局变量啊！

执行这个文件，命令行会输出如下信息：

```js
{
  id: '.',
  exports: { '$': [Function] },
  parent: null,
  filename: 'G:\\git-2019\\geek-nodejs\\02-commonJS\\01-test.js',
  loaded: false,
  children:
    [{
      id:
        'G:\\git-2019\\geek-nodejs\\node_modules\\jquery\\dist\\jquery.js',
      exports: [Function],
      parent: [Circular],
      filename:
        'G:\\git-2019\\geek-nodejs\\node_modules\\jquery\\dist\\jquery.js',
      loaded: true,
      children: [],
      paths: [Array]
    }],
  paths:
    ['G:\\git-2019\\geek-nodejs\\02-commonJS\\node_modules',
      'G:\\git-2019\\geek-nodejs\\node_modules',
      'G:\\git-2019\\node_modules',
      'G:\\node_modules']
}

//{ '$': [Function] }
```

> 我没想到module的pasht属性居然是这样获取模块的！即先看当前 JS 文件是否存在node_modules，不存在那就往上一级找！直到找到为止！

如果在命令行下调用某个模块，比如`node something.js`，那么`module.parent`就是`null`。如果是在脚本之中调用，比如`require('./something.js')`，那么`module.parent`就是调用它的模块。如上边的 `node 01-test.js`，`01-test.js`里边调用了 `require('jquery')`，那么该 `jquery.js`模块的父模块就是 `01-test.js`啦！即 `.`(`Circular`)

利用这一点，可以判断当前模块是否为入口脚本。因为入口脚本是咩有 `parent`的，即为`null`

```
if (!module.parent) {
    // ran with `node something.js`
    app.listen(8088, function() {
        console.log('app listening on port 8088');
    })
} else {
    // used with `require('/.something.js')`
    module.exports = app;
}
```

**module.exports属性：**

> `module.exports`属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取`module.exports`变量。

**exports变量：**

> 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。

```js
var exports = module.exports;
```

而这样做所造成的结果是，在对外输出模块接口时，可以向exports对象添加方法

```js
exports.area = function (r) {
  return Math.PI * r * r;
};

exports.circumference = function (r) {
  return 2 * Math.PI * r;
};
```

注意，不能直接将exports变量指向一个值，因为这样等于切断了`exports`与`module.exports`的联系。

```js
exports = function(x) {console.log(x)};
```

上面这样的写法是无效的，因为`exports`不再指向`module.exports`了

下面的写法也是无效的。

```js
exports.hello = function() {
  return 'hello';
};

module.exports = 'Hello world';
```

上面代码中，`hello`函数是无法对外输出的，因为`module.exports`被重新赋值了。

这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用`exports`输出，只能使用`module.exports`输出。

```js
module.exports = function (x){ console.log(x);};
```

如果你觉得，`exports`与`module.exports`之间的区别很难分清，一个简单的处理方法，就是放弃使用`exports`，只使用`module.exports`。

> 分清它们方法很简单，你每次都假想 每个模块头部，有一行这样的命令 :
>
> `var exports = module.exports`

**AMD规范与CommonJS规范区别：**

> CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。

说白了就是一个AMD需要发送请求，而 CommonJS 则不需要！而这意味着浏览器端用AMD，而服务器端则用 CommonJS 

不过现在，浏览器端用的是ES6模块规范，而不是AMD规范！而且服务端，也有逐步向着ES6模块规范靠近！

那么AMD规范长啥样呢？

AMD规范使用define方法定义模块，下面就是一个例子：

```js
define(['package/lib'], function(lib){
  function foo(){
    lib.log('hello world!');
  }

  return {
    foo: foo
  };
});
```

当然，AMD规范是允许输出的模块兼容CommonJS规范，这时`define`方法需要写成下面这样：

```js
define(function (require, exports, module){
  var someModule = require("someModule");
  var anotherModule = require("anotherModule");

  someModule.doTehAwesome();
  anotherModule.doMoarAwesome();

  exports.asplode = function (){
    someModule.doTehAwesome();
    anotherModule.doMoarAwesome();
  };
});
```

> 函数参数里边的函数体代码就是 遵循CommonJS 规范书写的代码呀！

**➹：**[CommonJS - Wikipedia](https://en.wikipedia.org/wiki/CommonJS)

### ②require命令？

**基本用法：**

Node使用CommonJS模块规范，内置的`require`命令用于加载模块文件。

`require`命令的基本功能是，**读入并执行**一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。

如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在`module.exports`变量上面。

**加载规则：**

> `require`命令用于加载文件，后缀名默认为`.js`。

即你可以写后缀，也可以不写后缀，但在ES6里边是需要写的！

根据参数的不同格式，`require`命令去不同路径寻找模块文件。

参数字符串以什么开头？

1. `/`：表示加载的是一个位于绝对路径的模块文件。比如，`require('/home/marco/foo.js')`将加载`/home/marco/foo.js`。
2. `./`：表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，`require('./circle')`将加载当前脚本同一目录的`circle.js`。
3. 以上二者都不是：表示加载的是一个**默认提供的核心模块**（位于Node的系统安装目录中），或者**一个位于各级node_modules目录的已安装模块**（全局安装或局部安装）。

第三点，举例来说，脚本`/home/user/projects/foo.js`执行了`require('bar.js')`命令，Node会依次搜索以下文件。

```
/usr/local/lib/node/bar.js
/home/user/projects/node_modules/bar.js
/home/user/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
```

> 说白了就是，先看node提供的API模块，接着就是从同级的 `node_modules`下的模块文件开始逐渐上一步台阶往上找：

![1570554989414](img/02/1570554989414.png)

为啥要这样设计呢？或者说这样设计的目的是啥？

这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。

4. 不以“./“或”/“开头，而且是一个路径，比如`require('example-module/path/to/file')`，则将先找到`example-module`的位置，然后再以它为参数，找到后续路径。

   > 我的测试 `require('03-test/a.js')`
   >
   > 直接去找相对于当前 JS 文件的 `node_modules/03-test/a.js`

5. 如果指定的模块文件没有发现，Node会尝试为文件名添加`.js`、`.json`、`.node`后，再去搜索。`.js`件会以文本格式的JavaScript脚本文件解析，`.json`文件会以JSON格式的文本文件解析，`.node`文件会以编译后的二进制文件解析。

6. 如果想得到`require`命令加载的确切文件名，使用`require.resolve()`方法。

**目录的加载规则：**

